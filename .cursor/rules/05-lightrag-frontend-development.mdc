---
alwaysApply: false
---

# LightRAG å‰ç«¯å¼€å‘è§„åˆ™ (2025ç‰ˆ)

## ğŸ¨ å‰ç«¯æ¶æ„æ¦‚è§ˆ

LightRAG Web UI åŸºäº2025å¹´æœ€æ–°ReactæŠ€æœ¯æ ˆæ„å»ºï¼Œæä¾›æ–‡æ¡£ç®¡ç†ã€çŸ¥è¯†å›¾è°±å¯è§†åŒ–å’Œæ™ºèƒ½é—®ç­”ç•Œé¢ã€‚

### ğŸš€ 2025å¹´æŠ€æœ¯æ ˆå‡çº§
- **React 19**: ä½¿ç”¨use()ã€useOptimisticã€useFormStatusç­‰æ–°ç‰¹æ€§
- **Vite 7**: æ›¿ä»£Create React Appï¼Œæé€Ÿå¼€å‘å’Œæ„å»º
- **TypeScript 5.6**: æœ€æ–°ç±»å‹ç³»ç»Ÿå’Œè¯­æ³•æ”¯æŒ
- **Vitest 2.0**: ç°ä»£åŒ–æµ‹è¯•æ¡†æ¶ï¼Œå®Œå…¨æ›¿ä»£Jest
- **TanStack Query 5**: çŠ¶æ€ç®¡ç†å’Œæ•°æ®è·å–
- **Zustand 5**: è½»é‡çº§çŠ¶æ€ç®¡ç†
- **Tailwind CSS 3.4**: æ ·å¼è§£å†³æ–¹æ¡ˆ
- **shadcn/ui**: ç»„ä»¶åº“åŸºç¡€

## ğŸ“‚ å‰ç«¯é¡¹ç›®ç»“æ„ (2025ä¼˜åŒ–ç‰ˆ)

```
lightrag_webui/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/                    # APIæ¥å£å±‚
â”‚   â”‚   â””â”€â”€ lightrag.ts        # LightRAG APIå®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ components/             # ç»„ä»¶åº“
â”‚   â”‚   â”œâ”€â”€ ui/                # åŸºç¡€UIç»„ä»¶(shadcn/ui)
â”‚   â”‚   â”œâ”€â”€ documents/         # æ–‡æ¡£ç®¡ç†ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ graph/             # å›¾è°±å¯è§†åŒ–ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ retrieval/         # æŸ¥è¯¢ç•Œé¢ç»„ä»¶
â”‚   â”‚   â””â”€â”€ status/            # çŠ¶æ€ç›‘æ§ç»„ä»¶
â”‚   â”œâ”€â”€ features/               # åŠŸèƒ½æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ DocumentManager.tsx
â”‚   â”‚   â”œâ”€â”€ GraphViewer.tsx
â”‚   â”‚   â””â”€â”€ RetrievalTesting.tsx
â”‚   â”œâ”€â”€ hooks/                  # è‡ªå®šä¹‰Hooks
â”‚   â”‚   â”œâ”€â”€ useLightragGraph.tsx
â”‚   â”‚   â”œâ”€â”€ useQueryModes.tsx   # 2025æ–°å¢
â”‚   â”‚   â””â”€â”€ useStreamingQuery.tsx # 2025æ–°å¢
â”‚   â”œâ”€â”€ stores/                 # ZustandçŠ¶æ€ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ graph.ts
â”‚   â”‚   â”œâ”€â”€ settings.ts
â”‚   â”‚   â””â”€â”€ query.ts           # 2025æ–°å¢
â”‚   â”œâ”€â”€ lib/                   # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ utils.ts
â”‚   â”‚   â”œâ”€â”€ query-classifier.ts # 2025æ–°å¢
â”‚   â”‚   â””â”€â”€ performance.ts     # 2025æ–°å¢
â”‚   â””â”€â”€ types/                 # TypeScriptç±»å‹å®šä¹‰
â”‚       â”œâ”€â”€ api.ts
â”‚       â”œâ”€â”€ graph.ts
â”‚       â””â”€â”€ query.ts           # 2025æ–°å¢
â”œâ”€â”€ package.json               # 2025ä¾èµ–é…ç½®
â”œâ”€â”€ vite.config.ts            # Vite 7é…ç½®
â”œâ”€â”€ vitest.config.ts          # Vitestæµ‹è¯•é…ç½®
â”œâ”€â”€ tailwind.config.js        # Tailwind CSSé…ç½®
â””â”€â”€ tsconfig.json             # TypeScripté…ç½®
```

## ğŸ”§ 2025å¹´Vite 7é…ç½®æœ€ä½³å®è·µ

### vite.config.tsä¼˜åŒ–é…ç½®
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'

export default defineConfig({
  plugins: [
    react({
      // React 19ä¼˜åŒ–
      babel: {
        plugins: [
          ['@babel/plugin-transform-react-jsx', { runtime: 'automatic' }]
        ]
      }
    })
  ],
  
  // 2025å¹´æ„å»ºä¼˜åŒ–
  build: {
    target: 'esnext',
    minify: 'esbuild',
    sourcemap: false,
    
    // ä»£ç åˆ†å‰²ä¼˜åŒ–
    rollupOptions: {
      output: {
        manualChunks: {
          // Reactæ ¸å¿ƒåº“
          'react-vendor': ['react', 'react-dom'],
          
          // UIç»„ä»¶åº“
          'ui-vendor': [
            '@radix-ui/react-dialog',
            '@radix-ui/react-toast',
            '@radix-ui/react-dropdown-menu'
          ],
          
          // å›¾è°±å¯è§†åŒ–
          'graph-vendor': ['cytoscape', 'd3'],
          
          // çŠ¶æ€ç®¡ç†å’Œæ•°æ®è·å–
          'state-vendor': ['zustand', '@tanstack/react-query'],
          
          // å·¥å…·åº“
          'utils-vendor': ['lodash-es', 'date-fns']
        }
      }
    },
    
    // æ€§èƒ½ä¼˜åŒ–
    chunkSizeWarningLimit: 1000
  },
  
  // å¼€å‘æœåŠ¡å™¨é…ç½®
  server: {
    port: 3000,
    host: true,
    proxy: {
      // APIä»£ç†åˆ°åç«¯
      '/api': {
        target: 'http://localhost:9621',
        changeOrigin: true
      }
    }
  },
  
  // è·¯å¾„åˆ«å
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@/components': resolve(__dirname, 'src/components'),
      '@/hooks': resolve(__dirname, 'src/hooks'),
      '@/stores': resolve(__dirname, 'src/stores'),
      '@/lib': resolve(__dirname, 'src/lib'),
      '@/types': resolve(__dirname, 'src/types')
    }
  },
  
  // ç¯å¢ƒå˜é‡
  define: {
    __DEV__: JSON.stringify(process.env.NODE_ENV === 'development')
  }
})
```

### package.json 2025å¹´ä¾èµ–é…ç½®
```json
{
  "name": "lightrag-webui",
  "version": "2.0.0",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "lint": "eslint src --ext ts,tsx",
    "lint:fix": "eslint src --ext ts,tsx --fix",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "@tanstack/react-query": "^5.0.0",
    "zustand": "^5.0.0",
    "react-router-dom": "^6.26.0",
    "react-i18next": "^14.0.0",
    
    "tailwindcss": "^3.4.0",
    "@tailwindcss/typography": "^0.5.0",
    
    "@radix-ui/react-dialog": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.0",
    "@radix-ui/react-dropdown-menu": "^2.1.0",
    "@radix-ui/react-select": "^2.1.0",
    "lucide-react": "^0.400.0",
    
    "cytoscape": "^3.29.0",
    "cytoscape-cola": "^2.5.0",
    "react-cytoscapejs": "^2.0.0",
    
    "axios": "^1.7.0",
    "lodash-es": "^4.17.21",
    "date-fns": "^3.6.0",
    "clsx": "^2.1.0",
    "class-variance-authority": "^0.7.0"
  },
  "devDependencies": {
    "vite": "^7.0.0",
    "@vitejs/plugin-react": "^4.3.0",
    "typescript": "^5.6.0",
    
    "vitest": "^2.0.0",
    "@testing-library/react": "^16.0.0",
    "@testing-library/jest-dom": "^6.4.0",
    "@testing-library/user-event": "^14.5.0",
    
    "eslint": "^9.0.0",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "eslint-plugin-react": "^7.35.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0",
    
    "@types/react": "^18.3.0",
    "@types/react-dom": "^18.3.0",
    "@types/lodash-es": "^4.17.0"
  }
}
```

## âš›ï¸ React 19æ–°ç‰¹æ€§åº”ç”¨

### 1. use() Hookæ•°æ®è·å–
```typescript
// ä½¿ç”¨use()æ›¿ä»£useEffectè¿›è¡Œæ•°æ®è·å–
import { use, Suspense } from 'react'

interface DocumentListProps {
  documentsPromise: Promise<Document[]>
}

function DocumentList({ documentsPromise }: DocumentListProps) {
  const documents = use(documentsPromise) // ç›´æ¥ä½¿ç”¨Promise
  
  return (
    <div className="space-y-4">
      {documents.map(doc => (
        <DocumentCard key={doc.id} document={doc} />
      ))}
    </div>
  )
}

// åœ¨çˆ¶ç»„ä»¶ä¸­ä½¿ç”¨
function DocumentManager() {
  const documentsPromise = useMemo(() => 
    api.getDocuments(), [refresh]
  )
  
  return (
    <Suspense fallback={<DocumentListSkeleton />}>
      <DocumentList documentsPromise={documentsPromise} />
    </Suspense>
  )
}
```

### 2. useOptimisticä¹è§‚æ›´æ–°
```typescript
// å®ç°æŸ¥è¯¢çš„ä¹è§‚æ›´æ–°
import { useOptimistic, useTransition } from 'react'

interface QueryResult {
  id: string
  query: string
  result: string
  timestamp: number
  status: 'pending' | 'completed' | 'error'
}

function QueryInterface() {
  const [queries, setQueries] = useState<QueryResult[]>([])
  const [isPending, startTransition] = useTransition()
  
  const [optimisticQueries, addOptimisticQuery] = useOptimistic(
    queries,
    (state, newQuery: QueryResult) => [...state, newQuery]
  )
  
  const handleQuery = async (queryText: string) => {
    const optimisticQuery: QueryResult = {
      id: Date.now().toString(),
      query: queryText,
      result: '',
      timestamp: Date.now(),
      status: 'pending'
    }
    
    // ä¹è§‚æ›´æ–°UI
    addOptimisticQuery(optimisticQuery)
    
    try {
      const result = await api.query({
        query: queryText,
        mode: 'hybrid',
        enable_rerank: true
      })
      
      // å®é™…ç»“æœè¿”å›åæ›´æ–°çŠ¶æ€
      startTransition(() => {
        setQueries(prev => [
          ...prev,
          { ...optimisticQuery, result, status: 'completed' }
        ])
      })
    } catch (error) {
      startTransition(() => {
        setQueries(prev => [
          ...prev,
          { ...optimisticQuery, result: error.message, status: 'error' }
        ])
      })
    }
  }
  
  return (
    <div className="space-y-4">
      <QueryForm onSubmit={handleQuery} disabled={isPending} />
      <QueryHistory queries={optimisticQueries} />
    </div>
  )
}
```

### 3. useFormStatusè¡¨å•çŠ¶æ€
```typescript
// æ–‡æ¡£ä¸Šä¼ è¡¨å•çš„çŠ¶æ€ç®¡ç†
import { useFormStatus } from 'react'

function UploadForm() {
  const uploadDocument = async (formData: FormData) => {
    try {
      await api.uploadDocument(formData)
      // ä¸Šä¼ æˆåŠŸå¤„ç†
    } catch (error) {
      // é”™è¯¯å¤„ç†
    }
  }
  
  return (
    <form action={uploadDocument} className="space-y-4">
      <FileInput name="file" accept=".txt,.pdf,.md" />
      <SubmitButton />
    </form>
  )
}

function SubmitButton() {
  const { pending } = useFormStatus()
  
  return (
    <button
      type="submit"
      disabled={pending}
      className={cn(
        "px-4 py-2 rounded-md font-medium transition-colors",
        pending 
          ? "bg-gray-400 cursor-not-allowed" 
          : "bg-blue-600 hover:bg-blue-700 text-white"
      )}
    >
      {pending ? (
        <>
          <Loader2 className="w-4 h-4 mr-2 animate-spin" />
          ä¸Šä¼ ä¸­...
        </>
      ) : (
        'ä¸Šä¼ æ–‡æ¡£'
      )}
    </button>
  )
}
```

## ğŸ¯ çŠ¶æ€ç®¡ç†æœ€ä½³å®è·µ (Zustand 5)

### æŸ¥è¯¢çŠ¶æ€ç®¡ç†
```typescript
// stores/query.ts - 2025å¹´æŸ¥è¯¢çŠ¶æ€ç®¡ç†
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

export type QueryMode = 'naive' | 'local' | 'global' | 'hybrid' | 'mix' | 'bypass'

interface QueryState {
  // æŸ¥è¯¢å†å²
  history: QueryResult[]
  
  // å½“å‰è®¾ç½®
  currentMode: QueryMode
  enableRerank: boolean
  topK: number
  
  // æµå¼æŸ¥è¯¢çŠ¶æ€
  streamingQuery: string | null
  streamingResult: string
  
  // æ€§èƒ½ç»Ÿè®¡
  performanceStats: {
    [mode: string]: {
      averageTime: number
      successRate: number
      totalQueries: number
    }
  }
  
  // Actions
  addQuery: (query: QueryResult) => void
  setMode: (mode: QueryMode) => void
  setRerank: (enabled: boolean) => void
  setTopK: (k: number) => void
  
  // æµå¼æŸ¥è¯¢
  startStreaming: (query: string) => void
  appendStreamResult: (chunk: string) => void
  endStreaming: () => void
  
  // æ€§èƒ½ç»Ÿè®¡
  updatePerformanceStats: (mode: QueryMode, duration: number, success: boolean) => void
  
  // æ™ºèƒ½æ¨¡å¼é€‰æ‹©
  suggestMode: (query: string) => QueryMode
}

export const useQueryStore = create<QueryState>()(
  devtools(
    persist(
      (set, get) => ({
        history: [],
        currentMode: 'hybrid',
        enableRerank: true,
        topK: 10,
        streamingQuery: null,
        streamingResult: '',
        performanceStats: {},
        
        addQuery: (query) => set((state) => ({
          history: [query, ...state.history.slice(0, 99)] // ä¿ç•™æœ€è¿‘100æ¡
        })),
        
        setMode: (mode) => set({ currentMode: mode }),
        setRerank: (enabled) => set({ enableRerank: enabled }),
        setTopK: (k) => set({ topK: k }),
        
        startStreaming: (query) => set({
          streamingQuery: query,
          streamingResult: ''
        }),
        
        appendStreamResult: (chunk) => set((state) => ({
          streamingResult: state.streamingResult + chunk
        })),
        
        endStreaming: () => set({
          streamingQuery: null,
          streamingResult: ''
        }),
        
        updatePerformanceStats: (mode, duration, success) => set((state) => {
          const stats = state.performanceStats[mode] || {
            averageTime: 0,
            successRate: 0,
            totalQueries: 0
          }
          
          const newTotal = stats.totalQueries + 1
          const newAverageTime = (stats.averageTime * stats.totalQueries + duration) / newTotal
          const newSuccessRate = (stats.successRate * stats.totalQueries + (success ? 1 : 0)) / newTotal
          
          return {
            performanceStats: {
              ...state.performanceStats,
              [mode]: {
                averageTime: newAverageTime,
                successRate: newSuccessRate,
                totalQueries: newTotal
              }
            }
          }
        }),
        
        suggestMode: (query) => {
          // æ™ºèƒ½æ¨¡å¼é€‰æ‹©é€»è¾‘
          const queryLower = query.toLowerCase()
          
          if (queryLower.includes('æ¯”è¾ƒ') || queryLower.includes('åˆ†æ')) {
            return 'mix'
          } else if (queryLower.includes('ä»€ä¹ˆæ˜¯') || queryLower.includes('å®šä¹‰')) {
            return 'global'
          } else if (queryLower.includes('è¯¦ç»†') || queryLower.includes('å…·ä½“')) {
            return 'local'
          } else {
            return 'hybrid'
          }
        }
      }),
      {
        name: 'lightrag-query-store',
        partialize: (state) => ({
          currentMode: state.currentMode,
          enableRerank: state.enableRerank,
          topK: state.topK,
          performanceStats: state.performanceStats
        })
      }
    ),
    { name: 'QueryStore' }
  )
)
```

## ğŸ”„ æ•°æ®è·å–æœ€ä½³å®è·µ (TanStack Query 5)

### APIå®¢æˆ·ç«¯è®¾è®¡
```typescript
// api/lightrag.ts - 2025å¹´APIå®¢æˆ·ç«¯
import { QueryClient } from '@tanstack/react-query'

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿ
      gcTime: 10 * 60 * 1000,   // 10åˆ†é’Ÿ (åŸcacheTime)
      retry: (failureCount, error) => {
        // æ™ºèƒ½é‡è¯•ç­–ç•¥
        if (error.status === 404) return false
        return failureCount < 3
      },
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000)
    }
  }
})

// Query Keyså·¥å‚
export const queryKeys = {
  documents: {
    all: ['documents'] as const,
    list: () => [...queryKeys.documents.all, 'list'] as const,
    detail: (id: string) => [...queryKeys.documents.all, 'detail', id] as const,
    status: () => [...queryKeys.documents.all, 'status'] as const
  },
  query: {
    all: ['query'] as const,
    result: (params: QueryParams) => [...queryKeys.query.all, 'result', params] as const,
    modes: () => [...queryKeys.query.all, 'modes'] as const,
    performance: () => [...queryKeys.query.all, 'performance'] as const
  },
  graph: {
    all: ['graph'] as const,
    stats: () => [...queryKeys.graph.all, 'stats'] as const,
    entities: () => [...queryKeys.graph.all, 'entities'] as const,
    relationships: () => [...queryKeys.graph.all, 'relationships'] as const
  }
}

// APIå‡½æ•°
export const api = {
  // æŸ¥è¯¢ç›¸å…³
  query: async (params: QueryParams): Promise<QueryResult> => {
    const response = await fetch('/api/query', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(params)
    })
    
    if (!response.ok) {
      throw new Error(`æŸ¥è¯¢å¤±è´¥: ${response.statusText}`)
    }
    
    return response.json()
  },
  
  // æµå¼æŸ¥è¯¢
  queryStream: async function* (params: QueryParams): AsyncGenerator<string> {
    const response = await fetch('/api/query/stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(params)
    })
    
    if (!response.body) throw new Error('æµå¼å“åº”ä¸å¯ç”¨')
    
    const reader = response.body.getReader()
    const decoder = new TextDecoder()
    
    try {
      while (true) {
        const { done, value } = await reader.read()
        if (done) break
        
        const chunk = decoder.decode(value, { stream: true })
        const lines = chunk.split('\n\n')
        
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6))
            if (data.chunk) {
              yield data.chunk
            }
          }
        }
      }
    } finally {
      reader.releaseLock()
    }
  },
  
  // æ–‡æ¡£ç®¡ç†
  uploadDocument: async (formData: FormData): Promise<UploadResult> => {
    const response = await fetch('/api/documents/upload', {
      method: 'POST',
      body: formData
    })
    
    if (!response.ok) {
      throw new Error(`ä¸Šä¼ å¤±è´¥: ${response.statusText}`)
    }
    
    return response.json()
  },
  
  getDocuments: async (): Promise<Document[]> => {
    const response = await fetch('/api/documents')
    if (!response.ok) throw new Error('è·å–æ–‡æ¡£åˆ—è¡¨å¤±è´¥')
    return response.json()
  }
}
```

### è‡ªå®šä¹‰Hooks
```typescript
// hooks/useStreamingQuery.tsx - æµå¼æŸ¥è¯¢Hook
import { useState, useCallback } from 'react'
import { useQueryStore } from '@/stores/query'

export function useStreamingQuery() {
  const [isStreaming, setIsStreaming] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  const {
    streamingQuery,
    streamingResult,
    startStreaming,
    appendStreamResult,
    endStreaming
  } = useQueryStore()
  
  const startQuery = useCallback(async (params: QueryParams) => {
    if (isStreaming) return
    
    setIsStreaming(true)
    setError(null)
    startStreaming(params.query)
    
    try {
      for await (const chunk of api.queryStream(params)) {
        appendStreamResult(chunk)
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'æŸ¥è¯¢å¤±è´¥')
    } finally {
      setIsStreaming(false)
      endStreaming()
    }
  }, [isStreaming, startStreaming, appendStreamResult, endStreaming])
  
  return {
    startQuery,
    isStreaming,
    error,
    query: streamingQuery,
    result: streamingResult
  }
}

// hooks/useQueryModes.tsx - æŸ¥è¯¢æ¨¡å¼ç®¡ç†
import { useQuery } from '@tanstack/react-query'

export function useQueryModes() {
  const { currentMode, setMode, suggestMode } = useQueryStore()
  
  // è·å–æ”¯æŒçš„æŸ¥è¯¢æ¨¡å¼
  const { data: modes = [], isLoading } = useQuery({
    queryKey: queryKeys.query.modes(),
    queryFn: async () => {
      const response = await fetch('/api/query/modes')
      return response.json()
    },
    staleTime: Infinity // æŸ¥è¯¢æ¨¡å¼å¾ˆå°‘å˜åŒ–
  })
  
  const selectMode = useCallback((mode: QueryMode) => {
    setMode(mode)
  }, [setMode])
  
  const autoSelectMode = useCallback((query: string) => {
    const suggested = suggestMode(query)
    setMode(suggested)
    return suggested
  }, [suggestMode, setMode])
  
  return {
    modes,
    isLoading,
    currentMode,
    selectMode,
    autoSelectMode
  }
}
```

## ğŸ¨ ç»„ä»¶è®¾è®¡æ¨¡å¼ (2025ç‰ˆ)

### å¤åˆç»„ä»¶æ¨¡å¼
```typescript
// components/QueryInterface/index.tsx
interface QueryInterfaceProps {
  className?: string
  onQueryComplete?: (result: QueryResult) => void
}

export function QueryInterface({ className, onQueryComplete }: QueryInterfaceProps) {
  return (
    <div className={cn("space-y-6", className)}>
      <QueryInterface.ModeSelector />
      <QueryInterface.InputForm />
      <QueryInterface.PerformanceStats />
      <QueryInterface.History />
    </div>
  )
}

// å­ç»„ä»¶
QueryInterface.ModeSelector = function ModeSelector() {
  const { modes, currentMode, selectMode } = useQueryModes()
  
  return (
    <Select value={currentMode} onValueChange={selectMode}>
      <SelectTrigger>
        <SelectValue />
      </SelectTrigger>
      <SelectContent>
        {modes.map(mode => (
          <SelectItem key={mode.value} value={mode.value}>
            <div className="flex items-center justify-between w-full">
              <span>{mode.label}</span>
              <Badge variant="secondary">{mode.avgTime}s</Badge>
            </div>
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  )
}

QueryInterface.InputForm = function InputForm() {
  const { startQuery } = useStreamingQuery()
  const { currentMode, enableRerank, topK } = useQueryStore()
  
  const handleSubmit = async (formData: FormData) => {
    const query = formData.get('query') as string
    
    await startQuery({
      query,
      mode: currentMode,
      enable_rerank: enableRerank,
      chunk_top_k: topK
    })
  }
  
  return (
    <form action={handleSubmit} className="space-y-4">
      <Textarea
        name="query"
        placeholder="è¾“å…¥æ‚¨çš„é—®é¢˜..."
        className="min-h-[100px]"
        required
      />
      <div className="flex justify-between items-center">
        <QuerySettings />
        <SubmitButton />
      </div>
    </form>
  )
}
```

## ğŸ§ª æµ‹è¯•æœ€ä½³å®è·µ (Vitest 2.0)

### vitest.config.ts
```typescript
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./src/test/setup.ts'],
    css: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.d.ts'
      ]
    }
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  }
})
```

### ç»„ä»¶æµ‹è¯•ç¤ºä¾‹
```typescript
// components/__tests__/QueryInterface.test.tsx
import { render, screen, userEvent } from '@testing-library/react'
import { QueryProvider } from '@/providers/QueryProvider'
import { QueryInterface } from '@/components/QueryInterface'

const TestWrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryProvider>
    {children}
  </QueryProvider>
)

describe('QueryInterface', () => {
  it('åº”è¯¥æ­£ç¡®æ¸²æŸ“æŸ¥è¯¢ç•Œé¢', () => {
    render(<QueryInterface />, { wrapper: TestWrapper })
    
    expect(screen.getByPlaceholderText('è¾“å…¥æ‚¨çš„é—®é¢˜...')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /æäº¤/i })).toBeInTheDocument()
  })
  
  it('åº”è¯¥æ”¯æŒæŸ¥è¯¢æ¨¡å¼åˆ‡æ¢', async () => {
    const user = userEvent.setup()
    render(<QueryInterface />, { wrapper: TestWrapper })
    
    const modeSelector = screen.getByRole('combobox')
    await user.click(modeSelector)
    
    const hybridOption = screen.getByText('æ··åˆæ£€ç´¢')
    await user.click(hybridOption)
    
    expect(screen.getByDisplayValue('hybrid')).toBeInTheDocument()
  })
  
  it('åº”è¯¥æ”¯æŒæµå¼æŸ¥è¯¢', async () => {
    const user = userEvent.setup()
    const mockStartQuery = vi.fn()
    
    // Mock useStreamingQuery hook
    vi.mock('@/hooks/useStreamingQuery', () => ({
      useStreamingQuery: () => ({
        startQuery: mockStartQuery,
        isStreaming: false,
        error: null
      })
    }))
    
    render(<QueryInterface />, { wrapper: TestWrapper })
    
    const queryInput = screen.getByPlaceholderText('è¾“å…¥æ‚¨çš„é—®é¢˜...')
    const submitButton = screen.getByRole('button', { name: /æäº¤/i })
    
    await user.type(queryInput, 'ä»€ä¹ˆæ˜¯äººå·¥æ™ºèƒ½ï¼Ÿ')
    await user.click(submitButton)
    
    expect(mockStartQuery).toHaveBeenCalledWith({
      query: 'ä»€ä¹ˆæ˜¯äººå·¥æ™ºèƒ½ï¼Ÿ',
      mode: 'hybrid',
      enable_rerank: true,
      chunk_top_k: 10
    })
  })
})
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ– (2025ç‰ˆ)

### ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
```typescript
// è·¯ç”±çº§åˆ«ä»£ç åˆ†å‰²
import { lazy, Suspense } from 'react'
import { Routes, Route } from 'react-router-dom'

// æ‡’åŠ è½½é¡µé¢ç»„ä»¶
const DocumentManager = lazy(() => import('@/features/DocumentManager'))
const GraphViewer = lazy(() => import('@/features/GraphViewer'))
const RetrievalTesting = lazy(() => import('@/features/RetrievalTesting'))

function App() {
  return (
    <Routes>
      <Route 
        path="/documents" 
        element={
          <Suspense fallback={<PageSkeleton />}>
            <DocumentManager />
          </Suspense>
        } 
      />
      <Route 
        path="/graph" 
        element={
          <Suspense fallback={<GraphSkeleton />}>
            <GraphViewer />
          </Suspense>
        } 
      />
      <Route 
        path="/query" 
        element={
          <Suspense fallback={<QuerySkeleton />}>
            <RetrievalTesting />
          </Suspense>
        } 
      />
    </Routes>
  )
}
```

### è™šæ‹ŸåŒ–é•¿åˆ—è¡¨
```typescript
// å¯¹äºå¤§é‡æ•°æ®çš„æ–‡æ¡£åˆ—è¡¨ï¼Œä½¿ç”¨è™šæ‹ŸåŒ–
import { FixedSizeList as List } from 'react-window'

interface DocumentListProps {
  documents: Document[]
}

function VirtualizedDocumentList({ documents }: DocumentListProps) {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {
    const document = documents[index]
    
    return (
      <div style={style} className="border-b">
        <DocumentCard document={document} />
      </div>
    )
  }
  
  return (
    <List
      height={600}
      itemCount={documents.length}
      itemSize={120}
      className="scrollbar-thin"
    >
      {Row}
    </List>
  )
}
```

## ğŸ’¡ å¼€å‘æœ€ä½³å®è·µæ€»ç»“

1. **React 19ä¼˜å…ˆ**: ä½¿ç”¨æ–°ç‰¹æ€§æå‡å¼€å‘æ•ˆç‡å’Œç”¨æˆ·ä½“éªŒ
2. **Vite 7æ„å»º**: æé€Ÿå¼€å‘ç¯å¢ƒå’Œä¼˜åŒ–çš„ç”Ÿäº§æ„å»º
3. **TypeScriptä¸¥æ ¼æ¨¡å¼**: ç±»å‹å®‰å…¨å’Œæ›´å¥½çš„å¼€å‘ä½“éªŒ
4. **ç»„ä»¶å¤ç”¨**: ä½¿ç”¨å¤åˆç»„ä»¶æ¨¡å¼å’Œè‡ªå®šä¹‰Hooks
5. **çŠ¶æ€ç®¡ç†**: Zustandå¤„ç†æœ¬åœ°çŠ¶æ€ï¼ŒTanStack Queryå¤„ç†æœåŠ¡å™¨çŠ¶æ€
6. **æ€§èƒ½ä¼˜åŒ–**: ä»£ç åˆ†å‰²ã€æ‡’åŠ è½½ã€è™šæ‹ŸåŒ–ã€ç¼“å­˜ç­–ç•¥
7. **æµ‹è¯•è¦†ç›–**: Vitest + Testing Libraryç¡®ä¿ä»£ç è´¨é‡
8. **ç”¨æˆ·ä½“éªŒ**: ä¹è§‚æ›´æ–°ã€åŠ è½½çŠ¶æ€ã€é”™è¯¯è¾¹ç•Œ
9. **å¯è®¿é—®æ€§**: éµå¾ªWCAGæŒ‡å—ï¼Œæ”¯æŒé”®ç›˜å¯¼èˆª
10. **å›½é™…åŒ–**: react-i18nextæ”¯æŒå¤šè¯­è¨€

è¿™äº›2025å¹´çš„å‰ç«¯æŠ€æœ¯æ ˆå°†ä¸ºLightRAGé¡¹ç›®æä¾›ç°ä»£åŒ–ã€é«˜æ€§èƒ½çš„ç”¨æˆ·ç•Œé¢ï¼
# LightRAG å‰ç«¯å¼€å‘è§„åˆ™ (2025ç‰ˆ)

## ğŸ¨ å‰ç«¯æ¶æ„æ¦‚è§ˆ

LightRAG Web UI åŸºäº2025å¹´æœ€æ–°ReactæŠ€æœ¯æ ˆæ„å»ºï¼Œæä¾›æ–‡æ¡£ç®¡ç†ã€çŸ¥è¯†å›¾è°±å¯è§†åŒ–å’Œæ™ºèƒ½é—®ç­”ç•Œé¢ã€‚

### ğŸš€ 2025å¹´æŠ€æœ¯æ ˆå‡çº§
- **React 19**: ä½¿ç”¨use()ã€useOptimisticã€useFormStatusç­‰æ–°ç‰¹æ€§
- **Vite 7**: æ›¿ä»£Create React Appï¼Œæé€Ÿå¼€å‘å’Œæ„å»º
- **TypeScript 5.6**: æœ€æ–°ç±»å‹ç³»ç»Ÿå’Œè¯­æ³•æ”¯æŒ
- **Vitest 2.0**: ç°ä»£åŒ–æµ‹è¯•æ¡†æ¶ï¼Œå®Œå…¨æ›¿ä»£Jest
- **TanStack Query 5**: çŠ¶æ€ç®¡ç†å’Œæ•°æ®è·å–
- **Zustand 5**: è½»é‡çº§çŠ¶æ€ç®¡ç†
- **Tailwind CSS 3.4**: æ ·å¼è§£å†³æ–¹æ¡ˆ
- **shadcn/ui**: ç»„ä»¶åº“åŸºç¡€

## ğŸ“‚ å‰ç«¯é¡¹ç›®ç»“æ„ (2025ä¼˜åŒ–ç‰ˆ)

```
lightrag_webui/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/                    # APIæ¥å£å±‚
â”‚   â”‚   â””â”€â”€ lightrag.ts        # LightRAG APIå®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ components/             # ç»„ä»¶åº“
â”‚   â”‚   â”œâ”€â”€ ui/                # åŸºç¡€UIç»„ä»¶(shadcn/ui)
â”‚   â”‚   â”œâ”€â”€ documents/         # æ–‡æ¡£ç®¡ç†ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ graph/             # å›¾è°±å¯è§†åŒ–ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ retrieval/         # æŸ¥è¯¢ç•Œé¢ç»„ä»¶
â”‚   â”‚   â””â”€â”€ status/            # çŠ¶æ€ç›‘æ§ç»„ä»¶
â”‚   â”œâ”€â”€ features/               # åŠŸèƒ½æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ DocumentManager.tsx
â”‚   â”‚   â”œâ”€â”€ GraphViewer.tsx
â”‚   â”‚   â””â”€â”€ RetrievalTesting.tsx
â”‚   â”œâ”€â”€ hooks/                  # è‡ªå®šä¹‰Hooks
â”‚   â”‚   â”œâ”€â”€ useLightragGraph.tsx
â”‚   â”‚   â”œâ”€â”€ useQueryModes.tsx   # 2025æ–°å¢
â”‚   â”‚   â””â”€â”€ useStreamingQuery.tsx # 2025æ–°å¢
â”‚   â”œâ”€â”€ stores/                 # ZustandçŠ¶æ€ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ graph.ts
â”‚   â”‚   â”œâ”€â”€ settings.ts
â”‚   â”‚   â””â”€â”€ query.ts           # 2025æ–°å¢
â”‚   â”œâ”€â”€ lib/                   # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ utils.ts
â”‚   â”‚   â”œâ”€â”€ query-classifier.ts # 2025æ–°å¢
â”‚   â”‚   â””â”€â”€ performance.ts     # 2025æ–°å¢
â”‚   â””â”€â”€ types/                 # TypeScriptç±»å‹å®šä¹‰
â”‚       â”œâ”€â”€ api.ts
â”‚       â”œâ”€â”€ graph.ts
â”‚       â””â”€â”€ query.ts           # 2025æ–°å¢
â”œâ”€â”€ package.json               # 2025ä¾èµ–é…ç½®
â”œâ”€â”€ vite.config.ts            # Vite 7é…ç½®
â”œâ”€â”€ vitest.config.ts          # Vitestæµ‹è¯•é…ç½®
â”œâ”€â”€ tailwind.config.js        # Tailwind CSSé…ç½®
â””â”€â”€ tsconfig.json             # TypeScripté…ç½®
```

## ğŸ”§ 2025å¹´Vite 7é…ç½®æœ€ä½³å®è·µ

### vite.config.tsä¼˜åŒ–é…ç½®
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'

export default defineConfig({
  plugins: [
    react({
      // React 19ä¼˜åŒ–
      babel: {
        plugins: [
          ['@babel/plugin-transform-react-jsx', { runtime: 'automatic' }]
        ]
      }
    })
  ],
  
  // 2025å¹´æ„å»ºä¼˜åŒ–
  build: {
    target: 'esnext',
    minify: 'esbuild',
    sourcemap: false,
    
    // ä»£ç åˆ†å‰²ä¼˜åŒ–
    rollupOptions: {
      output: {
        manualChunks: {
          // Reactæ ¸å¿ƒåº“
          'react-vendor': ['react', 'react-dom'],
          
          // UIç»„ä»¶åº“
          'ui-vendor': [
            '@radix-ui/react-dialog',
            '@radix-ui/react-toast',
            '@radix-ui/react-dropdown-menu'
          ],
          
          // å›¾è°±å¯è§†åŒ–
          'graph-vendor': ['cytoscape', 'd3'],
          
          // çŠ¶æ€ç®¡ç†å’Œæ•°æ®è·å–
          'state-vendor': ['zustand', '@tanstack/react-query'],
          
          // å·¥å…·åº“
          'utils-vendor': ['lodash-es', 'date-fns']
        }
      }
    },
    
    // æ€§èƒ½ä¼˜åŒ–
    chunkSizeWarningLimit: 1000
  },
  
  // å¼€å‘æœåŠ¡å™¨é…ç½®
  server: {
    port: 3000,
    host: true,
    proxy: {
      // APIä»£ç†åˆ°åç«¯
      '/api': {
        target: 'http://localhost:9621',
        changeOrigin: true
      }
    }
  },
  
  // è·¯å¾„åˆ«å
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@/components': resolve(__dirname, 'src/components'),
      '@/hooks': resolve(__dirname, 'src/hooks'),
      '@/stores': resolve(__dirname, 'src/stores'),
      '@/lib': resolve(__dirname, 'src/lib'),
      '@/types': resolve(__dirname, 'src/types')
    }
  },
  
  // ç¯å¢ƒå˜é‡
  define: {
    __DEV__: JSON.stringify(process.env.NODE_ENV === 'development')
  }
})
```

### package.json 2025å¹´ä¾èµ–é…ç½®
```json
{
  "name": "lightrag-webui",
  "version": "2.0.0",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "lint": "eslint src --ext ts,tsx",
    "lint:fix": "eslint src --ext ts,tsx --fix",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "@tanstack/react-query": "^5.0.0",
    "zustand": "^5.0.0",
    "react-router-dom": "^6.26.0",
    "react-i18next": "^14.0.0",
    
    "tailwindcss": "^3.4.0",
    "@tailwindcss/typography": "^0.5.0",
    
    "@radix-ui/react-dialog": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.0",
    "@radix-ui/react-dropdown-menu": "^2.1.0",
    "@radix-ui/react-select": "^2.1.0",
    "lucide-react": "^0.400.0",
    
    "cytoscape": "^3.29.0",
    "cytoscape-cola": "^2.5.0",
    "react-cytoscapejs": "^2.0.0",
    
    "axios": "^1.7.0",
    "lodash-es": "^4.17.21",
    "date-fns": "^3.6.0",
    "clsx": "^2.1.0",
    "class-variance-authority": "^0.7.0"
  },
  "devDependencies": {
    "vite": "^7.0.0",
    "@vitejs/plugin-react": "^4.3.0",
    "typescript": "^5.6.0",
    
    "vitest": "^2.0.0",
    "@testing-library/react": "^16.0.0",
    "@testing-library/jest-dom": "^6.4.0",
    "@testing-library/user-event": "^14.5.0",
    
    "eslint": "^9.0.0",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "eslint-plugin-react": "^7.35.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0",
    
    "@types/react": "^18.3.0",
    "@types/react-dom": "^18.3.0",
    "@types/lodash-es": "^4.17.0"
  }
}
```

## âš›ï¸ React 19æ–°ç‰¹æ€§åº”ç”¨

### 1. use() Hookæ•°æ®è·å–
```typescript
// ä½¿ç”¨use()æ›¿ä»£useEffectè¿›è¡Œæ•°æ®è·å–
import { use, Suspense } from 'react'

interface DocumentListProps {
  documentsPromise: Promise<Document[]>
}

function DocumentList({ documentsPromise }: DocumentListProps) {
  const documents = use(documentsPromise) // ç›´æ¥ä½¿ç”¨Promise
  
  return (
    <div className="space-y-4">
      {documents.map(doc => (
        <DocumentCard key={doc.id} document={doc} />
      ))}
    </div>
  )
}

// åœ¨çˆ¶ç»„ä»¶ä¸­ä½¿ç”¨
function DocumentManager() {
  const documentsPromise = useMemo(() => 
    api.getDocuments(), [refresh]
  )
  
  return (
    <Suspense fallback={<DocumentListSkeleton />}>
      <DocumentList documentsPromise={documentsPromise} />
    </Suspense>
  )
}
```

### 2. useOptimisticä¹è§‚æ›´æ–°
```typescript
// å®ç°æŸ¥è¯¢çš„ä¹è§‚æ›´æ–°
import { useOptimistic, useTransition } from 'react'

interface QueryResult {
  id: string
  query: string
  result: string
  timestamp: number
  status: 'pending' | 'completed' | 'error'
}

function QueryInterface() {
  const [queries, setQueries] = useState<QueryResult[]>([])
  const [isPending, startTransition] = useTransition()
  
  const [optimisticQueries, addOptimisticQuery] = useOptimistic(
    queries,
    (state, newQuery: QueryResult) => [...state, newQuery]
  )
  
  const handleQuery = async (queryText: string) => {
    const optimisticQuery: QueryResult = {
      id: Date.now().toString(),
      query: queryText,
      result: '',
      timestamp: Date.now(),
      status: 'pending'
    }
    
    // ä¹è§‚æ›´æ–°UI
    addOptimisticQuery(optimisticQuery)
    
    try {
      const result = await api.query({
        query: queryText,
        mode: 'hybrid',
        enable_rerank: true
      })
      
      // å®é™…ç»“æœè¿”å›åæ›´æ–°çŠ¶æ€
      startTransition(() => {
        setQueries(prev => [
          ...prev,
          { ...optimisticQuery, result, status: 'completed' }
        ])
      })
    } catch (error) {
      startTransition(() => {
        setQueries(prev => [
          ...prev,
          { ...optimisticQuery, result: error.message, status: 'error' }
        ])
      })
    }
  }
  
  return (
    <div className="space-y-4">
      <QueryForm onSubmit={handleQuery} disabled={isPending} />
      <QueryHistory queries={optimisticQueries} />
    </div>
  )
}
```

### 3. useFormStatusè¡¨å•çŠ¶æ€
```typescript
// æ–‡æ¡£ä¸Šä¼ è¡¨å•çš„çŠ¶æ€ç®¡ç†
import { useFormStatus } from 'react'

function UploadForm() {
  const uploadDocument = async (formData: FormData) => {
    try {
      await api.uploadDocument(formData)
      // ä¸Šä¼ æˆåŠŸå¤„ç†
    } catch (error) {
      // é”™è¯¯å¤„ç†
    }
  }
  
  return (
    <form action={uploadDocument} className="space-y-4">
      <FileInput name="file" accept=".txt,.pdf,.md" />
      <SubmitButton />
    </form>
  )
}

function SubmitButton() {
  const { pending } = useFormStatus()
  
  return (
    <button
      type="submit"
      disabled={pending}
      className={cn(
        "px-4 py-2 rounded-md font-medium transition-colors",
        pending 
          ? "bg-gray-400 cursor-not-allowed" 
          : "bg-blue-600 hover:bg-blue-700 text-white"
      )}
    >
      {pending ? (
        <>
          <Loader2 className="w-4 h-4 mr-2 animate-spin" />
          ä¸Šä¼ ä¸­...
        </>
      ) : (
        'ä¸Šä¼ æ–‡æ¡£'
      )}
    </button>
  )
}
```

## ğŸ¯ çŠ¶æ€ç®¡ç†æœ€ä½³å®è·µ (Zustand 5)

### æŸ¥è¯¢çŠ¶æ€ç®¡ç†
```typescript
// stores/query.ts - 2025å¹´æŸ¥è¯¢çŠ¶æ€ç®¡ç†
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

export type QueryMode = 'naive' | 'local' | 'global' | 'hybrid' | 'mix' | 'bypass'

interface QueryState {
  // æŸ¥è¯¢å†å²
  history: QueryResult[]
  
  // å½“å‰è®¾ç½®
  currentMode: QueryMode
  enableRerank: boolean
  topK: number
  
  // æµå¼æŸ¥è¯¢çŠ¶æ€
  streamingQuery: string | null
  streamingResult: string
  
  // æ€§èƒ½ç»Ÿè®¡
  performanceStats: {
    [mode: string]: {
      averageTime: number
      successRate: number
      totalQueries: number
    }
  }
  
  // Actions
  addQuery: (query: QueryResult) => void
  setMode: (mode: QueryMode) => void
  setRerank: (enabled: boolean) => void
  setTopK: (k: number) => void
  
  // æµå¼æŸ¥è¯¢
  startStreaming: (query: string) => void
  appendStreamResult: (chunk: string) => void
  endStreaming: () => void
  
  // æ€§èƒ½ç»Ÿè®¡
  updatePerformanceStats: (mode: QueryMode, duration: number, success: boolean) => void
  
  // æ™ºèƒ½æ¨¡å¼é€‰æ‹©
  suggestMode: (query: string) => QueryMode
}

export const useQueryStore = create<QueryState>()(
  devtools(
    persist(
      (set, get) => ({
        history: [],
        currentMode: 'hybrid',
        enableRerank: true,
        topK: 10,
        streamingQuery: null,
        streamingResult: '',
        performanceStats: {},
        
        addQuery: (query) => set((state) => ({
          history: [query, ...state.history.slice(0, 99)] // ä¿ç•™æœ€è¿‘100æ¡
        })),
        
        setMode: (mode) => set({ currentMode: mode }),
        setRerank: (enabled) => set({ enableRerank: enabled }),
        setTopK: (k) => set({ topK: k }),
        
        startStreaming: (query) => set({
          streamingQuery: query,
          streamingResult: ''
        }),
        
        appendStreamResult: (chunk) => set((state) => ({
          streamingResult: state.streamingResult + chunk
        })),
        
        endStreaming: () => set({
          streamingQuery: null,
          streamingResult: ''
        }),
        
        updatePerformanceStats: (mode, duration, success) => set((state) => {
          const stats = state.performanceStats[mode] || {
            averageTime: 0,
            successRate: 0,
            totalQueries: 0
          }
          
          const newTotal = stats.totalQueries + 1
          const newAverageTime = (stats.averageTime * stats.totalQueries + duration) / newTotal
          const newSuccessRate = (stats.successRate * stats.totalQueries + (success ? 1 : 0)) / newTotal
          
          return {
            performanceStats: {
              ...state.performanceStats,
              [mode]: {
                averageTime: newAverageTime,
                successRate: newSuccessRate,
                totalQueries: newTotal
              }
            }
          }
        }),
        
        suggestMode: (query) => {
          // æ™ºèƒ½æ¨¡å¼é€‰æ‹©é€»è¾‘
          const queryLower = query.toLowerCase()
          
          if (queryLower.includes('æ¯”è¾ƒ') || queryLower.includes('åˆ†æ')) {
            return 'mix'
          } else if (queryLower.includes('ä»€ä¹ˆæ˜¯') || queryLower.includes('å®šä¹‰')) {
            return 'global'
          } else if (queryLower.includes('è¯¦ç»†') || queryLower.includes('å…·ä½“')) {
            return 'local'
          } else {
            return 'hybrid'
          }
        }
      }),
      {
        name: 'lightrag-query-store',
        partialize: (state) => ({
          currentMode: state.currentMode,
          enableRerank: state.enableRerank,
          topK: state.topK,
          performanceStats: state.performanceStats
        })
      }
    ),
    { name: 'QueryStore' }
  )
)
```

## ğŸ”„ æ•°æ®è·å–æœ€ä½³å®è·µ (TanStack Query 5)

### APIå®¢æˆ·ç«¯è®¾è®¡
```typescript
// api/lightrag.ts - 2025å¹´APIå®¢æˆ·ç«¯
import { QueryClient } from '@tanstack/react-query'

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿ
      gcTime: 10 * 60 * 1000,   // 10åˆ†é’Ÿ (åŸcacheTime)
      retry: (failureCount, error) => {
        // æ™ºèƒ½é‡è¯•ç­–ç•¥
        if (error.status === 404) return false
        return failureCount < 3
      },
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000)
    }
  }
})

// Query Keyså·¥å‚
export const queryKeys = {
  documents: {
    all: ['documents'] as const,
    list: () => [...queryKeys.documents.all, 'list'] as const,
    detail: (id: string) => [...queryKeys.documents.all, 'detail', id] as const,
    status: () => [...queryKeys.documents.all, 'status'] as const
  },
  query: {
    all: ['query'] as const,
    result: (params: QueryParams) => [...queryKeys.query.all, 'result', params] as const,
    modes: () => [...queryKeys.query.all, 'modes'] as const,
    performance: () => [...queryKeys.query.all, 'performance'] as const
  },
  graph: {
    all: ['graph'] as const,
    stats: () => [...queryKeys.graph.all, 'stats'] as const,
    entities: () => [...queryKeys.graph.all, 'entities'] as const,
    relationships: () => [...queryKeys.graph.all, 'relationships'] as const
  }
}

// APIå‡½æ•°
export const api = {
  // æŸ¥è¯¢ç›¸å…³
  query: async (params: QueryParams): Promise<QueryResult> => {
    const response = await fetch('/api/query', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(params)
    })
    
    if (!response.ok) {
      throw new Error(`æŸ¥è¯¢å¤±è´¥: ${response.statusText}`)
    }
    
    return response.json()
  },
  
  // æµå¼æŸ¥è¯¢
  queryStream: async function* (params: QueryParams): AsyncGenerator<string> {
    const response = await fetch('/api/query/stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(params)
    })
    
    if (!response.body) throw new Error('æµå¼å“åº”ä¸å¯ç”¨')
    
    const reader = response.body.getReader()
    const decoder = new TextDecoder()
    
    try {
      while (true) {
        const { done, value } = await reader.read()
        if (done) break
        
        const chunk = decoder.decode(value, { stream: true })
        const lines = chunk.split('\n\n')
        
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6))
            if (data.chunk) {
              yield data.chunk
            }
          }
        }
      }
    } finally {
      reader.releaseLock()
    }
  },
  
  // æ–‡æ¡£ç®¡ç†
  uploadDocument: async (formData: FormData): Promise<UploadResult> => {
    const response = await fetch('/api/documents/upload', {
      method: 'POST',
      body: formData
    })
    
    if (!response.ok) {
      throw new Error(`ä¸Šä¼ å¤±è´¥: ${response.statusText}`)
    }
    
    return response.json()
  },
  
  getDocuments: async (): Promise<Document[]> => {
    const response = await fetch('/api/documents')
    if (!response.ok) throw new Error('è·å–æ–‡æ¡£åˆ—è¡¨å¤±è´¥')
    return response.json()
  }
}
```

### è‡ªå®šä¹‰Hooks
```typescript
// hooks/useStreamingQuery.tsx - æµå¼æŸ¥è¯¢Hook
import { useState, useCallback } from 'react'
import { useQueryStore } from '@/stores/query'

export function useStreamingQuery() {
  const [isStreaming, setIsStreaming] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  const {
    streamingQuery,
    streamingResult,
    startStreaming,
    appendStreamResult,
    endStreaming
  } = useQueryStore()
  
  const startQuery = useCallback(async (params: QueryParams) => {
    if (isStreaming) return
    
    setIsStreaming(true)
    setError(null)
    startStreaming(params.query)
    
    try {
      for await (const chunk of api.queryStream(params)) {
        appendStreamResult(chunk)
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'æŸ¥è¯¢å¤±è´¥')
    } finally {
      setIsStreaming(false)
      endStreaming()
    }
  }, [isStreaming, startStreaming, appendStreamResult, endStreaming])
  
  return {
    startQuery,
    isStreaming,
    error,
    query: streamingQuery,
    result: streamingResult
  }
}

// hooks/useQueryModes.tsx - æŸ¥è¯¢æ¨¡å¼ç®¡ç†
import { useQuery } from '@tanstack/react-query'

export function useQueryModes() {
  const { currentMode, setMode, suggestMode } = useQueryStore()
  
  // è·å–æ”¯æŒçš„æŸ¥è¯¢æ¨¡å¼
  const { data: modes = [], isLoading } = useQuery({
    queryKey: queryKeys.query.modes(),
    queryFn: async () => {
      const response = await fetch('/api/query/modes')
      return response.json()
    },
    staleTime: Infinity // æŸ¥è¯¢æ¨¡å¼å¾ˆå°‘å˜åŒ–
  })
  
  const selectMode = useCallback((mode: QueryMode) => {
    setMode(mode)
  }, [setMode])
  
  const autoSelectMode = useCallback((query: string) => {
    const suggested = suggestMode(query)
    setMode(suggested)
    return suggested
  }, [suggestMode, setMode])
  
  return {
    modes,
    isLoading,
    currentMode,
    selectMode,
    autoSelectMode
  }
}
```

## ğŸ¨ ç»„ä»¶è®¾è®¡æ¨¡å¼ (2025ç‰ˆ)

### å¤åˆç»„ä»¶æ¨¡å¼
```typescript
// components/QueryInterface/index.tsx
interface QueryInterfaceProps {
  className?: string
  onQueryComplete?: (result: QueryResult) => void
}

export function QueryInterface({ className, onQueryComplete }: QueryInterfaceProps) {
  return (
    <div className={cn("space-y-6", className)}>
      <QueryInterface.ModeSelector />
      <QueryInterface.InputForm />
      <QueryInterface.PerformanceStats />
      <QueryInterface.History />
    </div>
  )
}

// å­ç»„ä»¶
QueryInterface.ModeSelector = function ModeSelector() {
  const { modes, currentMode, selectMode } = useQueryModes()
  
  return (
    <Select value={currentMode} onValueChange={selectMode}>
      <SelectTrigger>
        <SelectValue />
      </SelectTrigger>
      <SelectContent>
        {modes.map(mode => (
          <SelectItem key={mode.value} value={mode.value}>
            <div className="flex items-center justify-between w-full">
              <span>{mode.label}</span>
              <Badge variant="secondary">{mode.avgTime}s</Badge>
            </div>
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  )
}

QueryInterface.InputForm = function InputForm() {
  const { startQuery } = useStreamingQuery()
  const { currentMode, enableRerank, topK } = useQueryStore()
  
  const handleSubmit = async (formData: FormData) => {
    const query = formData.get('query') as string
    
    await startQuery({
      query,
      mode: currentMode,
      enable_rerank: enableRerank,
      chunk_top_k: topK
    })
  }
  
  return (
    <form action={handleSubmit} className="space-y-4">
      <Textarea
        name="query"
        placeholder="è¾“å…¥æ‚¨çš„é—®é¢˜..."
        className="min-h-[100px]"
        required
      />
      <div className="flex justify-between items-center">
        <QuerySettings />
        <SubmitButton />
      </div>
    </form>
  )
}
```

## ğŸ§ª æµ‹è¯•æœ€ä½³å®è·µ (Vitest 2.0)

### vitest.config.ts
```typescript
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./src/test/setup.ts'],
    css: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.d.ts'
      ]
    }
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  }
})
```

### ç»„ä»¶æµ‹è¯•ç¤ºä¾‹
```typescript
// components/__tests__/QueryInterface.test.tsx
import { render, screen, userEvent } from '@testing-library/react'
import { QueryProvider } from '@/providers/QueryProvider'
import { QueryInterface } from '@/components/QueryInterface'

const TestWrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryProvider>
    {children}
  </QueryProvider>
)

describe('QueryInterface', () => {
  it('åº”è¯¥æ­£ç¡®æ¸²æŸ“æŸ¥è¯¢ç•Œé¢', () => {
    render(<QueryInterface />, { wrapper: TestWrapper })
    
    expect(screen.getByPlaceholderText('è¾“å…¥æ‚¨çš„é—®é¢˜...')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /æäº¤/i })).toBeInTheDocument()
  })
  
  it('åº”è¯¥æ”¯æŒæŸ¥è¯¢æ¨¡å¼åˆ‡æ¢', async () => {
    const user = userEvent.setup()
    render(<QueryInterface />, { wrapper: TestWrapper })
    
    const modeSelector = screen.getByRole('combobox')
    await user.click(modeSelector)
    
    const hybridOption = screen.getByText('æ··åˆæ£€ç´¢')
    await user.click(hybridOption)
    
    expect(screen.getByDisplayValue('hybrid')).toBeInTheDocument()
  })
  
  it('åº”è¯¥æ”¯æŒæµå¼æŸ¥è¯¢', async () => {
    const user = userEvent.setup()
    const mockStartQuery = vi.fn()
    
    // Mock useStreamingQuery hook
    vi.mock('@/hooks/useStreamingQuery', () => ({
      useStreamingQuery: () => ({
        startQuery: mockStartQuery,
        isStreaming: false,
        error: null
      })
    }))
    
    render(<QueryInterface />, { wrapper: TestWrapper })
    
    const queryInput = screen.getByPlaceholderText('è¾“å…¥æ‚¨çš„é—®é¢˜...')
    const submitButton = screen.getByRole('button', { name: /æäº¤/i })
    
    await user.type(queryInput, 'ä»€ä¹ˆæ˜¯äººå·¥æ™ºèƒ½ï¼Ÿ')
    await user.click(submitButton)
    
    expect(mockStartQuery).toHaveBeenCalledWith({
      query: 'ä»€ä¹ˆæ˜¯äººå·¥æ™ºèƒ½ï¼Ÿ',
      mode: 'hybrid',
      enable_rerank: true,
      chunk_top_k: 10
    })
  })
})
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ– (2025ç‰ˆ)

### ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
```typescript
// è·¯ç”±çº§åˆ«ä»£ç åˆ†å‰²
import { lazy, Suspense } from 'react'
import { Routes, Route } from 'react-router-dom'

// æ‡’åŠ è½½é¡µé¢ç»„ä»¶
const DocumentManager = lazy(() => import('@/features/DocumentManager'))
const GraphViewer = lazy(() => import('@/features/GraphViewer'))
const RetrievalTesting = lazy(() => import('@/features/RetrievalTesting'))

function App() {
  return (
    <Routes>
      <Route 
        path="/documents" 
        element={
          <Suspense fallback={<PageSkeleton />}>
            <DocumentManager />
          </Suspense>
        } 
      />
      <Route 
        path="/graph" 
        element={
          <Suspense fallback={<GraphSkeleton />}>
            <GraphViewer />
          </Suspense>
        } 
      />
      <Route 
        path="/query" 
        element={
          <Suspense fallback={<QuerySkeleton />}>
            <RetrievalTesting />
          </Suspense>
        } 
      />
    </Routes>
  )
}
```

### è™šæ‹ŸåŒ–é•¿åˆ—è¡¨
```typescript
// å¯¹äºå¤§é‡æ•°æ®çš„æ–‡æ¡£åˆ—è¡¨ï¼Œä½¿ç”¨è™šæ‹ŸåŒ–
import { FixedSizeList as List } from 'react-window'

interface DocumentListProps {
  documents: Document[]
}

function VirtualizedDocumentList({ documents }: DocumentListProps) {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {
    const document = documents[index]
    
    return (
      <div style={style} className="border-b">
        <DocumentCard document={document} />
      </div>
    )
  }
  
  return (
    <List
      height={600}
      itemCount={documents.length}
      itemSize={120}
      className="scrollbar-thin"
    >
      {Row}
    </List>
  )
}
```

## ğŸ’¡ å¼€å‘æœ€ä½³å®è·µæ€»ç»“

1. **React 19ä¼˜å…ˆ**: ä½¿ç”¨æ–°ç‰¹æ€§æå‡å¼€å‘æ•ˆç‡å’Œç”¨æˆ·ä½“éªŒ
2. **Vite 7æ„å»º**: æé€Ÿå¼€å‘ç¯å¢ƒå’Œä¼˜åŒ–çš„ç”Ÿäº§æ„å»º
3. **TypeScriptä¸¥æ ¼æ¨¡å¼**: ç±»å‹å®‰å…¨å’Œæ›´å¥½çš„å¼€å‘ä½“éªŒ
4. **ç»„ä»¶å¤ç”¨**: ä½¿ç”¨å¤åˆç»„ä»¶æ¨¡å¼å’Œè‡ªå®šä¹‰Hooks
5. **çŠ¶æ€ç®¡ç†**: Zustandå¤„ç†æœ¬åœ°çŠ¶æ€ï¼ŒTanStack Queryå¤„ç†æœåŠ¡å™¨çŠ¶æ€
6. **æ€§èƒ½ä¼˜åŒ–**: ä»£ç åˆ†å‰²ã€æ‡’åŠ è½½ã€è™šæ‹ŸåŒ–ã€ç¼“å­˜ç­–ç•¥
7. **æµ‹è¯•è¦†ç›–**: Vitest + Testing Libraryç¡®ä¿ä»£ç è´¨é‡
8. **ç”¨æˆ·ä½“éªŒ**: ä¹è§‚æ›´æ–°ã€åŠ è½½çŠ¶æ€ã€é”™è¯¯è¾¹ç•Œ
9. **å¯è®¿é—®æ€§**: éµå¾ªWCAGæŒ‡å—ï¼Œæ”¯æŒé”®ç›˜å¯¼èˆª
10. **å›½é™…åŒ–**: react-i18nextæ”¯æŒå¤šè¯­è¨€

è¿™äº›2025å¹´çš„å‰ç«¯æŠ€æœ¯æ ˆå°†ä¸ºLightRAGé¡¹ç›®æä¾›ç°ä»£åŒ–ã€é«˜æ€§èƒ½çš„ç”¨æˆ·ç•Œé¢ï¼
